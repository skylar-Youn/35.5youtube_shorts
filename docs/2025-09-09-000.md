# CapCut-Style Editor: Python FastAPI + Next.js (Initial Cut)

## Summary
- Backend (Python/FastAPI): Scroll capture (Playwright), asset ingest, project/timeline storage, MP4 rendering (moviepy + PIL).
- Frontend (Next.js): CapCut-like UI for timeline editing, assets, properties, script editing, and rendering.
- Storage: Per-project folders under `projects/<id>/` with `project.json`, `assets/`, `renders/`.

## Folder Layout
- `backend/` FastAPI app
  - `app.py` REST API
  - `models.py` Pydantic models (Project/Track/Clip/Template/Script)
  - `storage.py` project load/save/list helpers
  - `scroll_capture.py` deep image fetch via Playwright, image downloader
  - `render.py` timeline → MP4 (image/video/text/audio)
  - `requirements.txt` dependencies
- `editor/` Next.js UI
  - `app/page.tsx` shell layout
  - `components/` TopBar, AssetPanel, Timeline, Preview, Properties, ScriptEditor
  - `lib/store.ts` Zustand store (load/save/render actions)
  - `package.json`, `next.config.js`, `tsconfig.json`, `.env.local.example`
- Existing
  - `ui_app.py` (Streamlit app)
  - `shorts_maker2.py` (templating/TTS-capable renderer) — future integration target

## Setup: Backend
1) Install Python deps
   - `pip install -r backend/requirements.txt`
   - Playwright browser: `python -m playwright install chromium`
2) Run server
   - `python -m backend.app` (http://localhost:8000)

## Setup: Frontend
1) Node.js 18+
2) From `editor/`:
   - `npm i`
   - `cp .env.local.example .env.local` (defaults to `http://localhost:8000`)
   - `npm run dev` (http://localhost:3000)

## Core APIs
- `GET /health` → server check
- `GET /projects` → list projects
- `POST /projects { name }` → create project
- `GET /projects/{id}` / `PUT /projects/{id}` → load/save project JSON
- `POST /projects/{id}/assets/upload` (multipart) → add asset to project
- `POST /scroll/capture { url, mobile?, use_stealth? }` → discover image URLs via scroll
- `POST /projects/{id}/ingest_urls { urls }` → download URLs to `projects/<id>/assets/`
- `POST /render { project_id, out_name? }` → render MP4 to `projects/<id>/renders/`
- `POST /render/start { project_id }` → start background render, returns `{ jobId }`
- `GET /render/status/{jobId}` → JSON status `{ status, progress, path? }`
- `GET /render/sse/{jobId}` → SSE progress stream
- `GET /projects/{id}/srt/export` → export text track to SRT
- `POST /projects/{id}/srt/import { srt }` → import SRT into text track

## Editing Workflow (UI)
1) Create/select a project (TopBar).
2) Upload assets or use “URL 스크롤 가져오기” to fetch and ingest images.
3) Add clips to the timeline (이미지/텍스트). Save timeline.
4) Render → MP4 path returns; file saved under the project’s renders.
5) ScriptEditor lets you edit 제목/가격/특징/CTA for later template/TTS use.

## Rendering Notes
- Canvas: default 1080x1920 (9:16). Project controls width/height/fps/duration.
- Image: letterboxed fit with gentle Ken Burns zoom.
- Video: letterboxed to canvas, opacity and timing applied.
- Text: overlay with position (x,y in 0..1), size/color/alignment, opacity, start/duration.
- Audio: multiple audio clips mixed by timing.

## Scroll Capture Details
- Playwright (Chromium, stealth optional) loads page, clicks basic “더보기/Show more” then progressively scrolls to trigger lazy images.
- Collects `img` URLs from `src`/`data-src`/`srcset`, filters small/icons/placeholders.
- `ingest_urls` downloads images to project assets.

## Data Model (excerpt)
- Project
  - `tracks: Track[]` with kinds: `image`, `video`, `audio`, `text`
  - `clips: Clip[]` with `start`, `duration`, `transform { x,y,scale,opacity,rotation }`
  - Text clips: `text`, `text_size`, `text_color`, `text_align`
- Script: `title`, `price?`, `features[]`, `cta?`

## Roadmap / Next Steps
- Timeline UX: drag/resize clips, zoom, snapping, keyboard shortcuts.
- Clip properties panel: start/duration/x/y/scale/opacity/rotation editors.
- Templates: port `shorts_maker2.py` overlay system (top bar, CTA, bottom caption bar, badge styles) into `backend/render.py`.
- TTS: integrate Edge/Polly/Google/ElevenLabs into per-clip narration with Script mapping.
- Subtitles: SRT import/export and script-time alignment tools.
- Rendering queue: background worker + SSE/WebSocket progress.

## Troubleshooting
- Playwright errors: ensure `python -m playwright install chromium` ran; rerun with `use_stealth=false` if the site blocks.
- Fonts: renderer tries Nanum/DejaVu/Malgun; add a custom font if glyphs miss.
- Permissions: ensure the process can write to `projects/` (created automatically).

## Notes on Existing Code
- `ui_app.py` (Streamlit) and `shorts_maker2.py` remain unchanged; we can migrate advanced template/TTS logic gradually to the new backend renderer to avoid regressions.

codex
완전한 편집기 구조를 새로 잡고, 백엔드·프론트(UI)를 대대적으로 구성했
습니다. 파이썬으로 스크롤/가져오기(Playwright) + Next.js에서 캡컷 스
타일 편집(타임라인, 대본, 에셋, 렌더) 흐름으로 정리했습니다.

구성 개요

- 백엔드(FastAPI): 스크롤 캡처, 에셋 업로드/관리, 프로젝트/타임라인
저장, 렌더링(moviepy+PIL).
- 프론트(Next.js): 에셋 패널, 미리보기, 타임라인(텍스트/이미지/오디
오/비디오 트랙), 속성, 대본 편집, 렌더 버튼.
- 저장 구조: projects/<id>/project.json, assets/, renders/.

폴더와 주요 파일

- backend/
    - app.py: FastAPI 서버(프로젝트 CRUD, 업로드, 스크롤 캡처, 렌더)
    - models.py: 프로젝트/트랙/클립/템플릿/스크립트 모델
    - storage.py: 프로젝트 저장/로드/목록
    - scroll_capture.py: Playwright로 URL 스크롤+이미지 URL 수집, 다
운로드
    - render.py: 타임라인 → MP4 렌더(moviepy, 이미지/비디오/텍스트/오
디오 지원)
    - requirements.txt: 백엔드 의존성
- editor/ (Next.js 14 App Router)
    - app/page.tsx: 메인 레이아웃(TopBar + Assets + Preview +
Timeline + Properties + ScriptEditor)
    - components/*: UI 컴포넌트(TopBar, AssetPanel, Timeline,
Preview, Properties, ScriptEditor)
    - lib/store.ts: Zustand 스토어(프로젝트 상태/저장)
    - package.json, next.config.js, tsconfig.json, .env.local.example
- 문서
    - EDITOR.md: 실행/사용법, API 요약, 계획
    - README.md: 새 편집기 섹션 추가
- .gitignore: editor/node_modules/, projects/ 추가

지원 기능(현재)

- 영상/이미지/오디오/텍스트 트랙 모델링 및 저장.
- 에셋 업로드 또는 URL 스크롤 캡처 → 이미지 다운로드 → 에셋 등록.
- 타임라인에 이미지/텍스트 클립 추가/삭제, 프로젝트 저장.
- 기본 렌더링: 9:16 캔버스에서 이미지/비디오 레터박스, 텍스트 오버레
이, 오디오 믹스 출력.
- 대본 편집(제목/가격/특징/CTA) UI 포함. 향후 템플릿/자막/음성합성 연
계 용이.

실행 방법

- 백엔드
    - pip install -r backend/requirements.txt
    - Playwright 브라우저 설치: python -m playwright install chromium
    - 서버 실행: python -m backend.app (http://localhost:8000)
- 프론트
    - cd editor && npm i
    - cp .env.local.example .env.local (기본: http://localhost:8000)
    - npm run dev (http://localhost:3000)

UI 사용 흐름

- TopBar에서 “새 프로젝트” 생성 → 선택.
- AssetPanel에서 파일 업로드 또는 “URL 스크롤 가져오기”.
- Timeline에서 “이미지 클립 추가/텍스트 클립 추가” → “타임라인 저장”.
- 렌더 버튼 클릭 → projects/<id>/renders/*.mp4 생성 경로 팝업.

아키텍처 포인트

- 프로젝트 JSON 스키마: 트랙/클립/트랜스폼을 공통 모델로 관리 → 이후
키프레임/전환/오버레이 확장 용이.

다음 단계 제안

- 타임라인 UX 강화: 드래그·리사이즈, 줌, 스냅, 단축키.
- 클립 속성 편집: 시작/길이, 위치(x,y), 투명도, 스케일 등 UI화.
- 템플릿 적용: shorts_maker2.py의 고급 템플릿/오버레이와 TTS를
backend/render.py에 통합(현재도 구조적으로 호환됨).
- 자막/SRT 입출력과 대본-자막 싱크 도구.
- 렌더 진행률 SSE/WebSocket, 백그라운드 큐.

원하시면:

- 템플릿(상단바/CTA/하단 캡션) 오버레이를 현재 렌더에 바로 붙이고,
TTS/자막까지 통합해 드릴게요.
- 타임라인 드래그/리사이즈 가능한 인터랙션과 클립 속성 패널(숫자 입
력/슬라이더)도 추가 가능합니다.
pkill next-server

문서 업데이트:
    - README.md, EDITOR.md에 통합 실행 방법 추가
    - 최초 1회 준비: pip install -r backend/requirements.txt &&
python -m playwright install chromium
    - 실행: npm install && cp editor/.env.local.example
editor/.env.local && npm run dev
    - 서버: http://localhost:8000
    - 프론트: http://localhost:3000

추가로 원하시면:

- root npm install 시 Python 의존성 검사/안내 스크립트 추가
- Windows 호환 환경변수 설정(cross-env) 적용
- 에디터 자동 설치를 postinstall에서 강제하도록 조정 가능
문제 요약: 현재 폴더에서 잘못된 경로로 복사 시도했고, 3000 포트가 점유됐을 가능성이 있습니다.
    - 이미 editor/.env.local이 있으니 보통은 생략해도 됩니다.
    - 초기화가 필요하면 현재 editor 폴더에서 실행: cp .env.local.example .env.local
- 
    - 접속: http://localhost:3001
    - 백엔드 주소는 .env.local에 설정된 http://localhost:8000 사용
- 
3000 포트를 비우고 싶다면:
    - 점유 프로세스 확인: lsof -iTCP:3000 -sTCP:LISTEN -n -P
    - 종료: kill <PID> (필요시 강제 kill -9 <PID>)
    - 대안: npx kill-port 3000

    포트를 3100으로 변경했습니다.

- 변경 파일: editor/package.json
    - dev: next dev -p 3100
    - start: next start -p 3100 (프로덕션 시작 스크립트도 3100으로 통일)

다음 명령으로 실행하세요:

- cd editor && npm run dev
- 접속: http://localhost:3100
- 백엔드는 그대로 http://localhost:8000을 사용합니다 (.env.local 기준)

필요하면 start를 다시 3000으로 되돌리거나, 특정 환경에서만 포트를 바꾸도록 분리해드릴 수도 있어요.
